        -:    0:Source:closestgpslocation.c
        -:    0:Graph:closestgpslocation.gcno
        -:    0:Data:closestgpslocation.gcda
        -:    0:Runs:1
        -:    0:Source is newer than graph
        -:    1:#define _USE_MATH_DEFINES
        -:    2:
        -:    3:#include <stdio.h>
        -:    4:#include <math.h>
        -:    5:#include <ctype.h>
        -:    6:#include <string.h>
        -:    7:
        -:    8:#define EARTH_RADIUS 6371.0 // in km
        -:    9:
        -:   10:// Define a struct to store GPS location in decimal degree format
        -:   11:struct GPSLocation {
        -:   12:    double longitude;
        -:   13:    double latitude;
        -:   14:};
        -:   15:
        -:   16:// Calculate distance between two GPS coordinates using haversine formnula
    #####:   17:double calculateDistance(double long1, double lat1, double long2, double lat2) {
        -:   18:    // Convert GPS coordinates from degrees to radians
    #####:   19:    double long1Rad = long1 * M_PI / 180;
    #####:   20:    double lat1Rad = lat1 * M_PI / 180;
    #####:   21:    double long2Rad = long2 * M_PI / 180;
    #####:   22:    double lat2Rad = lat2 * M_PI / 180;
        -:   23:
        -:   24:    // Calculate differences in longitudes and latitudes
    #####:   25:    double dlong = long2Rad - long1Rad;
    #####:   26:    double dlat = lat2Rad - lat1Rad;
        -:   27:
        -:   28:    // Haversine formula
    #####:   29:    double a = pow(sin(dlat/2), 2) + cos(lat1Rad) * cos(lat2Rad) * pow(sin(dlong/2), 2);
        -:   30:    // Inverse haversine formula to calculate distance
    #####:   31:    double distance = 2 * EARTH_RADIUS * asin(sqrt(a));
        -:   32:
    #####:   33:    return distance;
        -:   34:}
        -:   35:
        -:   36:// Match each GPS location in Array 1 with closest GPS location in Array 2
    #####:   37:void findClosestGPSLocation(struct GPSLocation * arr1, int n1, struct GPSLocation * arr2, int n2) {
    #####:   38:    for (int i = 0; i < n1; i++) {
    #####:   39:        double minDistance = -1;
    #####:   40:        int closestIndex = -1;
    #####:   41:        for (int j = 0; j < n2; j++) {
    #####:   42:            double distance = calculateDistance(arr1[i].longitude, arr1[i].latitude, arr2[j].longitude, arr2[j].latitude);
    #####:   43:            if (minDistance == -1 || distance < minDistance) {
    #####:   44:                minDistance = distance;
    #####:   45:                closestIndex = j;
        -:   46:            }
        -:   47:        }
        -:   48:
    #####:   49:        printf("GPS location {%lf, %lf} in Array 1 is closest to GPS location {%lf, %lf} in Array 2 with a distance of %lf km.\n", arr1[i].longitude, arr1[i].latitude, arr2[closestIndex].longitude, arr2[closestIndex].latitude, minDistance);
        -:   50:    }
    #####:   51:}
        -:   52:
        -:   53:// stolen from stackoverflow
        2:   54:const char *get_filename_ext(const char *filename) {
        2:   55:    const char *dot = strrchr(filename, '.');
       2*:   56:    if (!dot || dot == filename) return "";
        2:   57:    return dot + 1;
        -:   58:}
        -:   59:
        -:   60:// function to detect and convert between longitude and latitude formats
    #####:   61:void convertGPSLocation(struct GPSLocation * coords) {
        -:   62:    // detect DMS format
        -:   63:
        -:   64:    // convert DMS to decimal degree format
        -:   65:
        -:   66:    // detect DM format
        -:   67:
        -:   68:    // convert DM to decimal degree format
        -:   69:
        -:   70:    // detect decimal degree format
        -:   71:
        -:   72:    // return decimal degree format
    #####:   73:}
        -:   74:
        -:   75:// function to store categories of the data table in an array
        2:   76:void storeCategories(char *categories, char **categoriesArray) {
        2:   77:    int i = 0;
       13:   78:    while (categories != NULL) {
      11*:   79:        while (isspace(*categories)) categories++; // ignore leading spaces
        -:   80:
        -:   81:        // ignore trailing spaces
       11:   82:        char *end = categories + strlen(categories) - 1;
       13:   83:        while (end > categories && isspace(*end)) {
        2:   84:            *end = '\0';
        2:   85:            end--;
        -:   86:        }
        -:   87:
       11:   88:        categoriesArray[i] = strdup(categories);
       11:   89:        categories = strtok(NULL, ",");
       11:   90:        i++;
        -:   91:    }
        2:   92:}
        -:   93:
        -:   94:// function for file processing
        1:   95:void processFile(FILE *infile, char fileType, char **categoriesArray, int longIndex, int latIndex) {
        -:   96:    if (fileType == 'c') {
        -:   97:        // process csv file
        -:   98:        
        -:   99:        // seperate the data into columns based on categories
        -:  100:        // if empty or invalid cell, ignore row
        -:  101:        // store the data in a struct array
        -:  102:        // remove leading and trailing spaces, leading and trailing quotes
        -:  103:
        -:  104:
        -:  105:        // convert the data to decimal degree format (call function)
        -:  106:
        -:  107:        // find the longitude and latitude columns
        -:  108:
        -:  109:        // write data from long and lat columns to a struct array
        -:  110:
        -:  111:
        -:  112:        
        -:  113:
        -:  114:    } else if (fileType == 'j') {
        -:  115:        // process json file
        -:  116:    }
        1:  117:}
        -:  118:
        1:  119:int main() {
        -:  120:    char row[100];
        -:  121:    char entryType1; // set as m for manual or f for file
        -:  122:    char entryType2; // set as m or f
        -:  123:    char fileType1; // set as c for csv or j for json
        -:  124:    char fileType2; // set as c or j
        -:  125:    char *categories;
        -:  126:    char *categories1Array[100];
        -:  127:    char *categories2Array[100];
        -:  128:
        -:  129:    FILE *infile1;
        -:  130:    FILE *infile2;
        -:  131:
        -:  132:    /////////////////////////////////////////////////////////////////////////////////////
        -:  133:    // Array 1
        -:  134:    // ask if user wants to input data manually or from a file
        1:  135:    printf("Array 1: Would you like to input the data manually or from a file? (m/f): ");
        1:  136:    fgets(row, sizeof(row), stdin);
        -:  137:    
        1:  138:    entryType1 = row[0];
        1:  139:    while (entryType1 != 'm' && entryType1 != 'f') {
    #####:  140:        printf("Error: Invalid entry type. Please try again: ");
    #####:  141:        fgets(row, sizeof(row), stdin);
    #####:  142:        entryType1 = row[0];
        -:  143:    }
        -:  144:
       1*:  145:    if (entryType1 == 'm') { // if user wants to input data manually
        -:  146:        // Declare buffer to store user input
        -:  147:        char buffer[100];
        -:  148:
        -:  149:        // Read number of GPS locations in Array 1
    #####:  150:        printf("Enter the number of GPS locations in Array 1: ");
        -:  151:        int n1;
    #####:  152:        fgets(buffer, sizeof(buffer), stdin);
        -:  153:
        -:  154:        // Check for valid input (valid integer less than or equal to 1)
    #####:  155:        while (sscanf(buffer, "%d", &n1) != 1 || n1 < 1) {
    #####:  156:            printf("Invalid input. Enter an integer greater than 0: ");
    #####:  157:            fgets(buffer, sizeof(buffer), stdin);
        -:  158:        }
        -:  159:
        -:  160:        // Read GPS locations in Array 1
    #####:  161:        struct GPSLocation arr1[n1];
    #####:  162:        for (int i = 0; i < n1; i++) {
    #####:  163:            printf("Enter GPS location %d: ", i + 1);
    #####:  164:            fgets(buffer, sizeof(buffer), stdin);
        -:  165:
        -:  166:            // Check for valid input (valid GPS location in decimal degree format)
    #####:  167:            while (sscanf(buffer, "%lf %lf", &arr1[i].longitude, &arr1[i].latitude) != 2 || arr1[i].longitude < -180 || arr1[i].longitude > 180 || arr1[i].latitude < -90 || arr1[i].latitude > 90) {
    #####:  168:                printf("Invalid input. Enter a valid GPS location in decimal degree format {longitude latitude}: ");
    #####:  169:                fgets(buffer, sizeof(buffer), stdin);
        -:  170:            }
        -:  171:        }
        -:  172:    } else { // if user wants to input data from a file
        -:  173:        // allow user to input file name of of the first csv/json file
        1:  174:        printf("Enter the name of the first data file: ");
        -:  175:    
        1:  176:        fgets(row, sizeof(row), stdin);
        1:  177:        row[strcspn(row, "\n")] = 0; // remove newline character
        -:  178:
        1:  179:        infile1 = fopen(row, "r");
        -:  180:
        1:  181:        if (infile1 == NULL) {
    #####:  182:            printf("Error: Unable to open file.\n");
    #####:  183:            return -1;
        -:  184:        }
        -:  185:
        -:  186:        // check if the file is a csv or json file
        1:  187:        if (strcmp(get_filename_ext(row), "csv") == 0) {
        1:  188:            fileType1 = 'c';
    #####:  189:        } else if (strcmp(get_filename_ext(row), "json") == 0) {
    #####:  190:            fileType1 = 'j';
        -:  191:        } else {
    #####:  192:            printf("Error: File type not supported.\n");
    #####:  193:            return -1;
        -:  194:        }
        -:  195:
        1:  196:        printf("Enter the categories of the data table in order from left to right, separated by commas: ");
        1:  197:        fgets(row, sizeof(row), stdin);
        1:  198:        categories = strtok(row, ",");
        -:  199:
        -:  200:        // store categories in an array
        1:  201:        storeCategories(categories, categories1Array);
        -:  202:    }
        -:  203:
        -:  204:    /////////////////////////////////////////////////////////////////////////////////////
        -:  205:    // Array 2
        -:  206:    // ask if user wants to input data manually or from a file
        1:  207:    printf("Array 2: Would you like to input the data manually or from a file? (m/f): ");
        1:  208:    fgets(row, sizeof(row), stdin);
        -:  209:    
        1:  210:    entryType2 = row[0];
        1:  211:    while (entryType2 != 'm' && entryType2 != 'f') {
    #####:  212:        printf("Error: Invalid entry type. Please try again: ");
    #####:  213:        fgets(row, sizeof(row), stdin);
    #####:  214:        entryType2 = row[0];
        -:  215:    }
        -:  216:
       1*:  217:    if (entryType2 == 'm') {
        -:  218:        // Declare buffer to store user input
        -:  219:        char buffer[100];
        -:  220:        // Read number of GPS locations in Array 2
    #####:  221:        printf("Enter the number of GPS locations in Array 2: ");
        -:  222:        int n2;
        -:  223:
        -:  224:        // Check for valid input (valid integer less than or equal to 1)
    #####:  225:        fgets(buffer, sizeof(buffer), stdin);
    #####:  226:        while (sscanf(buffer, "%d", &n2) != 1 || n2 < 1) {
    #####:  227:            printf("Invalid input. Enter an integer greater than 0: ");
    #####:  228:            fgets(buffer, sizeof(buffer), stdin);
        -:  229:        }
        -:  230:
        -:  231:        // Read GPS locations in Array 2
    #####:  232:        struct GPSLocation arr2[n2];
    #####:  233:        for (int i = 0; i < n2; i++) {
    #####:  234:            printf("Enter GPS location %d: ", i + 1);
    #####:  235:            fgets(buffer, sizeof(buffer), stdin);
        -:  236:
        -:  237:            // Check for valid input (valid GPS location in decimal degree format)
    #####:  238:            while (sscanf(buffer, "%lf %lf", &arr2[i].longitude, &arr2[i].latitude) != 2 || arr2[i].longitude < -180 || arr2[i].longitude > 180 || arr2[i].latitude < -90 || arr2[i].latitude > 90) {
    #####:  239:                printf("Invalid input. Enter a valid GPS location in decimal degree format {longitude latitude}: ");
    #####:  240:                fgets(buffer, sizeof(buffer), stdin);
        -:  241:            }
        -:  242:        }
        -:  243:    } else {
        -:  244:        // allow user to input file name of of the second csv/json file
        1:  245:        printf("Enter the name of the second data file: ");
        1:  246:        fgets(row, sizeof(row), stdin);
        -:  247:
        1:  248:        row[strcspn(row, "\n")] = 0; // remove newline character
        -:  249:        
        1:  250:        infile2 = fopen(row, "r");
        1:  251:        if (infile2 == NULL) {
    #####:  252:            printf("Error: Unable to open file.\n");
    #####:  253:            return -1;
        -:  254:        }
        -:  255:        
        -:  256:        // check if the file is a csv or json file
        1:  257:        if (strcmp(get_filename_ext(row), "csv") == 0) {
        1:  258:            fileType2 = 'c';
    #####:  259:        } else if (strcmp(get_filename_ext(row), "json") == 0) {
    #####:  260:            fileType2 = 'j';
        -:  261:        } else {
    #####:  262:            printf("Error: File type not supported.\n");
    #####:  263:            return -1;
        -:  264:        }
        -:  265:
        1:  266:        printf("Enter the categories of the data table in order from left to right, seperated by commas: ");
        1:  267:        fgets(row, sizeof(row), stdin);
        1:  268:        categories = strtok(row, ",");
        -:  269:
        -:  270:        // store categories in an array
        1:  271:        storeCategories(categories, categories2Array);
        -:  272:    }
        -:  273:   
        -:  274:    /////////////////////////////////////////////////////////////////////////////////////
        -:  275:    // for files: identify the longitude and latitude columns
        1:  276:    int long1Index = -1;
        1:  277:    int lat1Index = -1;
        1:  278:    int long2Index = -1;
        1:  279:    int lat2Index = -1;
        -:  280:
        1:  281:    if (entryType1 == 'f') {
        1:  282:        int i = 0;
        5:  283:        while(i < 100 && categories1Array[i] != NULL) {
        4:  284:            if (strcasecmp(categories1Array[i], "longitude") == 0 || \
        4:  285:            strcasecmp(categories1Array[i], "long") == 0 || \
        4:  286:            strcasecmp(categories1Array[i], "lon") == 0 || \
        4:  287:            strcasecmp(categories1Array[i], "lng") == 0 ) {
        1:  288:                long1Index = i;
        3:  289:            } else if (strcasecmp(categories1Array[i], "latitude") == 0 || \
        3:  290:            strcasecmp(categories1Array[i], "lat") == 0 ) {
        1:  291:                lat1Index = i;
        -:  292:            }
        4:  293:            i++;
        4:  294:        }
        -:  295:        if (long1Index == -1 || lat1Index == -1) {
        1:  296:            printf("Error: Longitude and latitude columns not found in the first data file.\n");
    #####:  297:            return -1;
    #####:  298:        }
        -:  299:    }
        -:  300:    
        -:  301:    if (entryType2 == 'f') {
        1:  302:        int i = 0;
        1:  303:        while (i < 100 && categories2Array[i] != NULL) {
       14:  304:            if (strcasecmp(categories2Array[i], "longitude") == 0 || \
       13:  305:            strcasecmp(categories2Array[i], "long") == 0 || \
       12:  306:            strcasecmp(categories2Array[i], "lon") == 0 || \
       12:  307:            strcasecmp(categories2Array[i], "lng") == 0 ) {
       12:  308:                long2Index = i;
        1:  309:            } else if (strcasecmp(categories2Array[i], "latitude") == 0 || \
       12:  310:            strcasecmp(categories2Array[i], "lat") == 0 ) {
       11:  311:                lat2Index = i;
        1:  312:            }
        -:  313:            i++;
       13:  314:        }
        -:  315:        if (long2Index == -1 || lat2Index == -1) {
        1:  316:            printf("Error: Longitude and latitude columns not found in the second data file.\n");
    #####:  317:            return -1;
    #####:  318:        }
        -:  319:
        -:  320:    }
        -:  321:
        -:  322:    /////////////////////////////////////////////////////////////////////////////////////
        -:  323:    // read the data from the csv/json files
        -:  324:    if (entryType1 == 'f') {
        1:  325:        processFile(infile1, fileType1, categories1Array, long1Index, lat1Index);
        1:  326:    }
        -:  327:    // if empty or invalid cell, ignore row
        -:  328:
        -:  329:    
        -:  330:
        -:  331:
        -:  332:    
        -:  333:    // // Match each GPS location in Array 1 with closest GPS location in Array 2
        -:  334:    // findClosestGPSLocation(arr1, n1, arr2, n2);
        -:  335:
        -:  336:    return 0;
        1:  337:
        -:  338:}
